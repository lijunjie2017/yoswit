<template>
  <div class="page">
    <div class="navbar active">
      <div class="navbar-bg"></div>
      <div class="navbar-inner sliding">
        <div class="left">
          <a href="#" class="button button-fill text-color-theme bg-color-white button-44 back">
            <i class="icon icon-back"></i>
            <span class="if-not-md">Back</span>
          </a>
        </div>
        <div class="title">{{ _('Restore Device Network') }}</div>
      </div>
    </div>

    <div class="page-content">
      {% raw %}
      <div id="vue-app" v-cloak>
        <div class="main-box">
          <div class="tabs">
            <div id="step-1" class="view tab view-main tab-active">
              <div
                class="list media-list no-margin list-group sortable sortable-network-wrapper"
                v-on:sortable:sort="onSortableSort"
                data-sortable-move-elements="false"
                v-if="totalDevices != 0"
                v-for="(kitem,kindex) in restoreList"
                :key="kindex"
              >
                <ul>
                  <li class="list-group-title display-flex justify-content-space-between">
                    <span>{{_('Network')}}{{kindex+1}}</span>
                    <div class="item-after"><span class="badge color-blue">{{kitem.length}}</span></div>
                  </li>
                  <li
                    class="device home-scanned-peripheral mobmob-device swipeout"
                    :guid="item.device"
                    is-network="true"
                    v-for="(item,index) in kitem"
                    :key="item.name"
                  >
                    <div class="item-content swipeout-content">
                      <!--<label class="checkbox" style="padding-left: 20px; padding-right: 20px"
                        ><input v-on:click="changeVal(item)" type="checkbox" :checked="item.checked?true:false" /><i
                          class="icon-checkbox"
                        ></i
                      ></label> -->
                      <div class="item-media" style="position: relative">
                        <img :src="erp.get_url(item.image?item.image:imgError)" width="60" />
                        <i
                          class="material-icons mesh-head"
                          :style="{'position':'absolute','left':'-5px','bottom':'-5px','font-size':'20px','display':item.meshHeadSet?'inline-block':'none','color':item.meshHeadConnect?'green':'red'}"
                          >{{item.meshHeadConnect?'link':'link_off'}}</i
                        >
                        <i
                          class="material-icons mesh-tail"
                          :style="{'position':'absolute','right':'-5px','bottom':'-5px','font-size':'20px','display':item.meshTailSet?'inline-block':'none','color':item.meshTailConnect?'green':'red'}"
                          >{{item.meshTailConnect?'link':'link_off'}}</i
                        >
                      </div>
                      <div class="item-inner">
                        <div class="item-title-row">
                          <div class="item-title">{{item.device_model}} - {{item.device_name.substring(0,12)}}</div>
                        </div>
                        <div class="item-subtitle text-muted">{{item.roomInfo}}</div>
                        <div class="signal-panel item-text height-21">
                          <div :signal="item.signal" :bluetooth="item.bluetooth" :mesh="item.meshSize?1:0">
                            <div class="signal"></div>
                            <div class="bluetooth"></div>
                            <div class="mesh" :pos="calcMeshSize(item.network_id)">
                              <span v-if="item.meshSize">{{item.meshSize?item.meshSize:0}}/{{calcMeshSize(item.network_id)}}</span>
                            </div>
                            <div class="mobmob"></div>
                            <div class="iostatus"></div>
                          </div>
                        </div>
                      </div>
                      <div class="control-panel-right"></div>
                    </div>
                    <div class="sortable-handler"></div>
                  </li>
                </ul>
              </div>
              <div class="row" style="margin-bottom: 15px; margin-top: 15px" v-if="restoreList.length != 0">
                <div class="col">
                  <div class="button button-fill button-save" v-on:click="confirmDeviceNetwork()">{{_("Confirm")}}</div>
                </div>
              </div>
            </div>
            <div
              id="step-0"
              class="view tab view-main"
              :class="[index == 0 || index == 1 ? 'tab-active' : '']"
              v-if="showUncat"
            >
              <div class="title-tip" style="padding: 0px 0px 15px 15px" v-show="titleStatus">
                <span class="text-muted">{{_('Please sort the device according to its physical location')}}</span>
              </div>
              <div
                class="list media-list no-margin list-group sortable sortable-network-wrapper"
                v-on:sortable:sort="onSortableSort"
                data-sortable-move-elements="false"
                v-if="totalDevices != 0"
              >
                <ul>
                  <li class="list-group-title display-flex justify-content-space-between">
                    <span>{{_('Unassigned')}}</span>
                    <div class="item-after"><span class="badge color-blue">{{totalDevices}}</span></div>
                  </li>
                  <li
                    class="device home-scanned-peripheral mobmob-device swipeout"
                    :guid="item.device"
                    is-network="true"
                    v-for="(item,index) in deviceList"
                    :key="item.name"
                  >
                    <div class="item-content swipeout-content">
                      <!--<label class="checkbox" style="padding-left: 20px; padding-right: 20px"
                        ><input v-on:click="changeVal(item)" type="checkbox" :checked="item.checked?true:false" /><i
                          class="icon-checkbox"
                        ></i
                      ></label> -->
                      <div class="item-media" style="position: relative">
                        <img :src="erp.get_url(item.image?item.image:imgError)" width="60" />
                        <i
                          class="material-icons mesh-head"
                          :style="{'position':'absolute','left':'-5px','bottom':'-5px','font-size':'20px','display':item.meshHeadSet?'inline-block':'none','color':item.meshHeadConnect?'green':'red'}"
                          >{{item.meshHeadConnect?'link':'link_off'}}</i
                        >
                        <i
                          class="material-icons mesh-tail"
                          :style="{'position':'absolute','right':'-5px','bottom':'-5px','font-size':'20px','display':item.meshTailSet?'inline-block':'none','color':item.meshTailConnect?'green':'red'}"
                          >{{item.meshTailConnect?'link':'link_off'}}</i
                        >
                      </div>
                      <div class="item-inner">
                        <div class="item-title-row">
                          <div class="item-title">{{item.device_model}} - {{item.device_name.substring(0,12)}}</div>
                        </div>
                        <div class="item-subtitle text-muted">{{item.roomInfo}}</div>
                        <div class="signal-panel item-text height-21">
                          <div :signal="item.signal" :bluetooth="item.bluetooth" :mesh="item.meshSize?1:0">
                            <div class="signal"></div>
                            <div class="bluetooth"></div>
                            <div class="mesh" :pos="calcMeshSize(item.network_id)">
                              <span v-if="item.meshSize">{{item.meshSize?item.meshSize:0}}/{{calcMeshSize(item.network_id)}}</span>
                            </div>
                            <div class="mobmob"></div>
                            <div class="iostatus"></div>
                          </div>
                        </div>
                      </div>
                      <div class="control-panel-right"></div>
                    </div>
                    <div class="sortable-handler"></div>
                  </li>
                </ul>
              </div>
              <!-- choose device div end -->
              <div class="device-null" v-if="totalDevices == 0">
                <div class="block" style="text-align: center">
                  <span class="material-icons" style="font-size: 100px; color: #ddd">meeting_room</span>
                  <p>${_('You don not have any network batch, create one')}</p>
                </div>
                <div class="block block-strong">
                  <p class="row">
                    <a class="col button button-large" v-on:click="createDevice()">{{ _('Create Device') }}</a>
                  </p>
                </div>
              </div>
              <div class="row" style="margin-bottom: 15px; margin-top: 15px" v-if="totalDevices">
                <div class="col">
                  <div class="button button-fill button-save" v-on:click="updateDeviceNetwork()">{{_("Restore")}}</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      {% endraw %}
    </div>
  </div>
</template>

<script>
  export default async (props, ctx) => {
    const $f7 = ctx.$f7,
      $f7route = ctx.$f7route,
      $onUnmounted = ctx.$onUnmounted,
      $on = ctx.$on;

    let vueApp = null;
    const { network_index, edit } = $f7route.query;
    $on('pageMounted', (e, page) => {
      vueApp = new Vue({
        el: page.el.querySelector('#vue-app'),
        data: {
          index: 0,
          titleTip: _('Choose Devices'),
          titleStatus: false,
          deviceList: [],
          uncatDeviceList: [],
          postDeviceList: [],
          networkIndex: 1,
          totalDevices: 0,
          uncatDevices: 0,
          imgError: 'https://my.yoswit.com/files/products/YO2086-1G.svg',
          sortStatus: false,
          restoreMap: {},
          deviceRestoreMap: {},
          restoreList: [], //[[network1],[network2]]
          showUncat : true,
        },
        watch: {
          index: function (newVal) {
            if (newVal == 1) {
              this.titleTip = _('Sort Devices');
              app.sortable.enable($('.sortable-network-wrapper'));
              this.titleStatus = true;
            } else {
              this.titleTip = _('Choose Devices');

              app.sortable.disable($('.sortable-network-wrapper'));
              this.titleStatus = false;
            }
          },
        },
        mounted() {
          this.networkIndex = network_index && network_index != 'undefined' ? network_index : 1;
          this.init();
          this.scan();
          //this.startScan();
        },
        methods: {
          toTab(index) {
            this.index = index;
            if (index == 1) {
              this.sortStatus = true;
              // this.titleTip = _('Sort Devices');
              // this.titleStatus = true;
              app.sortable.enable($('.sortable-network-wrapper'));
            } else {
              this.sortStatus = false;
              // this.titleStatus = false;
              // this.titleTip = _('Choose Devices');
            }
          },
          calcMeshSize(id) {
            if (id === '0') {
              return 0;
            } else {
              return this.deviceList.filter((e) => e.network_id === id).length;
            }
          },
          onSortableSort(event) {
            const from = event.detail.from;
            const to = event.detail.to;
            //get the target list
            let targetList = this.deviceList.filter((item) => this.dealwithShow(item));
            console.log('targetList', targetList);
            //let movedItem = targetList.splice(from - 1, 1)[0];
            //let targetItem = targetList.splice(to-1,1)[0];
            console.log('targetList[from - 1]', targetList[from - 1]);
            targetList[from - 1].network_position = to - 1;
            targetList[to - 1].network_position = from - 1;
            this.deviceList.forEach((item) => {
              targetList.forEach((kitem) => {
                if (item.device == kitem.device) {
                  item = kitem;
                  if (item.deviceNetworkSize > 1) {
                    if (isset(kitem.network_1)) {
                      let networkMapList = JSON.parse(kitem.network_1);
                      let idList = networkMapList.map((zitem) => zitem.network_id);
                      let checkIndex = idList.indexOf(this.networkIndex);
                      if (checkIndex != -1) {
                        networkMapList[checkIndex].network_position = kitem.network_position;
                        console.log('networkMapList[checkIndex]', networkMapList[checkIndex]);
                        item.network_1 = JSON.stringify(networkMapList);
                      }
                    }
                  }
                }
              });
            });
            this.deviceList = this.deviceList.sort((a, b) => {
              if (a.network_id === b.network_id) {
                return a.network_position - b.network_position; // 如果 network_id 相同，则比较 network_position
              } else {
                return a.network_id - b.network_id; // 否则比较 network_id
              }
            });
            console.log('this.deviceList', this.deviceList);
          },
          async init() {
            let devices = cloneDeep(erp.info.profile.profile_device);
            let subdevices = cloneDeep(erp.info.profile.profile_subdevice);
            //get the image
            devices.forEach((item) => {
              //choose status
              item.checked = false;
              item.isUsed = true;
              item.signal = 0;
              item.bluetooth = 0;
              item.mesh = 0;
              if (item.device) {
                let guid = item.device;
                const hexid = guid.substring(guid.length - 6, guid.length - 2);
                const model = erp.doctype.device_model[hexid.toUpperCase()];
                item.deviceNetworkSize = model.device_network_size ? model.device_network_size : 1;
                if (!model && !model.image) {
                  item.image = model.image;
                } else {
                  item.image = '';
                }
                //filter the room info
                item.roomInfo = '';
                subdevices.forEach((kitem) => {
                  if (kitem.device == item.device && kitem.device) {
                    item.roomInfo += `${tran(kitem.room_name)}-${tran(kitem.title)} `;
                  }
                });
                //show the mutiway size model
                if (isset(item.network_1)) {
                  let networkMapList = JSON.parse(item.network_1);
                  console.log('networkMapList', networkMapList);
                  let idList = networkMapList.map((idItem) => parseInt(idItem.network_id));
                  console.log('idList', idList);
                  let checkIndex = idList.indexOf(parseInt(this.networkIndex));
                  if (checkIndex > -1) {
                    item.network_id = this.networkIndex;
                    item.network_position = networkMapList[checkIndex].network_position;
                  }
                  //check if length == item.deviceNetworkSize
                  if (idList.indexOf(parseInt(this.networkIndex)) == -1 && idList.length == item.deviceNetworkSize) {
                    item.isUsed = false;
                  }
                }
              }
            });
            //this.postDeviceList = devices;
            this.deviceList = devices.sort((a, b) => {
              if (a.network_id === b.network_id) {
                return a.network_position - b.network_position; // 如果 network_id 相同，则比较 network_position
              } else {
                return a.network_id - b.network_id; // 否则比较 network_id
              }
            });
            this.deviceList = this.deviceList.filter((item) => item.network_id == 0);
            this.updateTotal();
          },
          nextStep() {
            if (this.index == 0) {
              if (this.totalDevices == 0 && edit == 0) {
                app.dialog.alert(_('No devices need to be networked'));
              } else {
                app.sortable.enable($('.sortable-network-wrapper'));
                this.saveDeviceInNetwork();
              }
            } else if (this.index == 1) {
              this.editDeviceInNetwork();
            }
          },
          dealwithShow(item) {
            if (edit == 1) {
              return item.network_id == this.networkIndex;
            } else {
              if (this.index == 1) {
                return item.network_id == this.networkIndex;
              } else {
                if (item.deviceNetworkSize > 1 && item.isUsed) {
                  return true;
                } else {
                  return item.network_id == this.networkIndex || item.network_id == 0;
                }
              }
            }
          },
          createDevice() {
            mainView.router.navigate('/mobile-app/yoswit-device-type');
          },
          changeUcatVal(item) {
            item.checked = !item.checked;
            if (item.checked) {
              item.network_id = this.networkIndex;
            } else {
              item.network_id = 0;
            }
            this.deviceList.forEach((kitem) => {
              if (kitem.device === item.device) {
                kitem.network_id = this.networkIndex;
                kitem.checked = true;
              }
            });
            console.log(item);
            this.updateTotal();
          },
          changeVal(item) {
            item.checked = !item.checked;
          },
          updateTotal() {
            if (edit == 1) {
              this.totalDevices = cloneDeep(this.deviceList).filter((item) => item.network_id === this.networkIndex).length;
              this.uncatDevices = this.uncatDeviceList.filter((kitem) => kitem.network_id == 0).length;
            } else {
              this.totalDevices = cloneDeep(this.deviceList).filter((item) => item.network_id == 0 || item.deviceNetworkSize > 1).length;
            }
          },
          async updateDeviceSettings() {},
          connectRetryDefaultPaw(guid) {
            return new Promise((resolve, reject) => {
              peripheral[guid]
                .connect()
                .then(() => {
                  resolve(1);
                })
                .catch((error) => {
                  if (error == 7200) {
                    //retry default paw
                    peripheral[guid].prop.password = '000000';
                    peripheral[guid]
                      .doConnect()
                      .then(() => {
                        resolve(1);
                      })
                      .catch((err) => {
                        reject(err);
                      });
                  } else {
                    reject(error);
                  }
                });
            });
          },
          revertStr(hexString) {
            let bytes = [];
            for (let i = 0; i < hexString.length; i += 2) {
              bytes.push(hexString.substr(i, 2));
            }
            const reversedHex = bytes.reverse();
            return reversedHex.join('');
          },
          async confirmDeviceNetwork(){
            app.dialog.preloader();
            //post the device info to erp
            let devices = cloneDeep(erp.info.profile.profile_device);
            let networks = cloneDeep(this.restoreList);
            networks.forEach((networkItem,networkIndex)=>{
              let networkDevices = networkItem || [];
              networkDevices.forEach((deviceItem,deviceIndex)=>{
                devices.forEach(kitem=>{
                  if(deviceItem.device == kitem.device){
                    kitem.network_id = parseInt(networkIndex)+1;
                    kitem.network_position = deviceIndex;
                  }
                })
              })
            });
            //update the erp and change
            try {
              await http2.request(encodeURI('/api/resource/Profile/' + erp.info.profile.name), {
                method: 'PUT',
                responseType: 'json',
                dataType: 'json',
                responseType: 'json',
                serializer: 'json',
                timeout: 60,
                data: {
                  profile_device: devices,
                },
              });
              app.dialog.close();
              erp.info.profile.profile_device = devices;
              emitter.emit("device_network_update",{});
              window.globalUpdate = true;
              mainView.router.back();
              //app.dialog.alert('Successfully');
            } catch (error) {
              app.dialog.close();
              app.dialog.alert(error);
            }
          },
          async findNextDevice(macRever) {
            let deviceMap = this.deviceList.find((d) => core_utils_get_mac_address_from_guid(d.device, true) === macRever);
            if (deviceMap) {
              try {
                let guid = deviceMap.device;
                await window.peripheral[guid].connect();
                console.log(peripheral[guid].prop.id);
                ble.startNotification(
                  peripheral[guid].prop.id,
                  'ff80',
                  'ff82',
                  (rs) => {
                    console.log('start notify');
                    console.log('rs', rs);
                    let headStatus = rs.substring(16, 18);
                    let macStr = rs.substring(4, 16);
                    debugger;
                    if (headStatus == '00') {
                      if (macStr != '000000000000') {
                        this.restoreMap['network_1'].unshift(this.revertStr(macStr));
                        this.findNextDevice(macStr);
                      }
                      console.log(this.restoreMap['network_1']);
                    } else if (headStatus == '01') {
                      if (macStr != '000000000000') {
                        this.restoreMap['network_1'].push(this.revertStr(macStr));
                        this.findNextDevice(macStr);
                      }
                      console.log(this.restoreMap['network_1']);
                    }
                  },
                  (notifyError) => {
                    console.log('notifyError', notifyError);
                  }
                );
                //850200 get the head,850201 get the tail
                //8500 2efc168d3a08 00(00:head;01:tail) 0000000001
                let bleList = [
                  {
                    service: 'ff80',
                    characteristic: 'ff81',
                    data: `850200`,
                  },
                  {
                    service: 'ff80',
                    characteristic: 'ff81',
                    data: `850201`,
                  },
                ];
                await window.peripheral[guid].write(bleList);
              } catch (error) {
                app.dialog.alert(_(erp.get_log_description(error)));
              }
            } else {
            }
          },
          async findDeviceHeadAndTail(guid) {
            let getHeadStatus = false;
            let getTailStatus = false;
            return new Promise(async (resolve, reject) => {
              try {
                let this_mac = core_utils_get_mac_address_from_guid(guid, true);
                await window.peripheral[guid].connect();
                ble.startNotification(
                  peripheral[guid].prop.id,
                  'ff80',
                  'ff82',
                  (rs) => {
                    console.log('start notify');
                    console.log('rs', rs);
                    let headStatus = rs.substring(16, 18);
                    let macStr = rs.substring(4, 16);
                    if (headStatus == '00') {
                      getHeadStatus = true;
                      if (getTailStatus) {
                        resolve(1);
                      }
                      if (macStr != '000000000000') {
                        // this.restoreMap['network_1'].unshift(this.revertStr(macStr));
                        // this.findNextDevice(macStr);
                        this.deviceRestoreMap[this_mac]['head_be_connect'] = macStr;
                      } else {
                        this.deviceRestoreMap[this_mac]['head_be_connect'] = 'none';
                      }
                    } else if (headStatus == '01') {
                      getTailStatus = true;
                      if (getHeadStatus) {
                        resolve(1);
                      }
                      //check if get the tailStatus
                      if (macStr != '000000000000') {
                        // this.restoreMap['network_1'].push(this.revertStr(macStr));
                        // this.findNextDevice(macStr);
                        this.deviceRestoreMap[this_mac]['tail_be_connect'] = macStr;
                      } else {
                        this.deviceRestoreMap[this_mac]['tail_be_connect'] = 'none';
                      }
                    } else {
                      reject(0);
                    }
                  },
                  (notifyError) => {
                    reject(notifyError);
                  }
                );
                //850200 get the head,850201 get the tail
                //8500 2efc168d3a08 00(00:head;01:tail) 0000000001
                let bleList = [
                  {
                    service: 'ff80',
                    characteristic: 'ff81',
                    data: `850200`,
                  },
                  {
                    service: 'ff80',
                    characteristic: 'ff81',
                    data: `850201`,
                  },
                ];
                await window.peripheral[guid].write(bleList);
              } catch (error) {
                reject(error);
              }
            });
          },
          async updateDeviceNetwork() {
            // for (let i = 1; i <= 20; i++) {
            //   this.restoreMap[`network_${i}`] = [];
            // }
            //send the command to the target device
            //form the list one start
            let thisList = cloneDeep(this.deviceList);
            //let deviceMap = thisList[0];
            app.dialog.confirm(
              `${_('Note: During the recovery process, the phone needs to scan the networking devices.')}`,
              async () => {
                const updateFun = async () => {
                  for (let i in thisList) {
                    if (thisList[i].updateStatus) {
                      continue;
                    }
                    try {
                      let guid = thisList[i].device;
                      //let this_mac = core_utils_get_mac_address_from_guid(guid).replace(/:/g, '');
                      let this_mac = core_utils_get_mac_address_from_guid(guid, true);
                      this.$toast = app.toast.create({
                        position: 'center',
                        text: `${_('Update')} ${thisList[i].device_model} <br /> ${thisList[i].roomInfo} ${this_mac}...`,
                      });
                      this.$toast.open();
                      this.deviceRestoreMap[this_mac] = {};
                      await this.findDeviceHeadAndTail(guid);
                      await window.peripheral[guid].disconnect();
                      thisList[i].updateStatus = true;
                      this.$toast.close();
                    } catch (error) {
                      //show which device error
                      console.log("error",error)
                      this.$toast.close();
                      let deviceInfo = `${thisList[i].roomInfo}`;
                      thisList[i].updateStatus = false;
                      app.dialog.confirm(
                        `${_('Update')} ${thisList[i].roomInfo} ${_('failed,retry?')}`,
                        () => {
                          updateFun();
                        },
                        () => {}
                      );
                      break;
                      //app.dialog.alert(_(erp.get_log_description(error)));
                    }
                  }
                  let allUpdateStatus = true;
                  thisList.forEach((item) => {
                    if (!item.updateStatus) {
                      allUpdateStatus = false;
                    }
                  });
                  if (allUpdateStatus) {
                    console.log('this.deviceRestoreMap', this.deviceRestoreMap);
                    //tindy the device info
                    let objMap = cloneDeep(this.deviceRestoreMap);
                    //check if results length is diff to the deviceList length
                    console.log("Object.keys(resultsMap)",Object.keys(objMap))
                    //check if missing other device

                    if(Object.keys(objMap).length != thisList.length){
                      app.dialog.alert(_('The network is incomplete, please check the network again.'));
                      return 
                    }
                    const lookup = { ...objMap };
                    console.log("lookup",lookup)
                    const results = [];
                    const headKeys = Object.keys(lookup).filter((key) => lookup[key].head_be_connect === 'none' && lookup[key].tail_be_connect != 'none');
                    //if no find the headKeys,error
                    if(headKeys.length == 0){
                      debugger
                      app.dialog.alert(_('The network is incomplete, please check the network again.'));
                      return 
                    }
                    console.log("headKeys",headKeys)
                    let missNetwork = [];
                    for (const headKey of headKeys) {
                      const connectedArray = [];
                      let currentKey = headKey;
                      while (currentKey) {
                        connectedArray.push(currentKey);
                        const tailBeConnect = lookup[currentKey].tail_be_connect;
                        if(!isset(lookup[tailBeConnect])){
                          if(tailBeConnect !='none'){
                            missNetwork.push(tailBeConnect);
                          }
                        }
                        console.log("tailBeConnect",tailBeConnect)
                        if (tailBeConnect === 'none') {
                          break;
                        }
                        currentKey = Object.keys(lookup).find((key) => lookup[key].head_be_connect === currentKey);
                        console.log("currentKey",currentKey);
                      }
                      results.push(connectedArray);
                    }
                    console.log('results', results);
                    let resultsMap = cloneDeep(results);
                    console.log("missNetwork",missNetwork);
                    if(missNetwork.length){
                      let missStr = missNetwork.map(item=>this.invertBytes(item)).join(',');
                      app.dialog.alert(_('The network is incomplete.Device with mac address ')+missStr +_(' is missing,please check the network again.'));
                      return 
                    }
                    let showList = [];
                    for (let i = 0; i < resultsMap.length; i++) {
                      for (let j = 0; j < resultsMap[i].length; j++) {
                        for (const z of thisList) {
                          const guid = z.device;
                          const macAddress = core_utils_get_mac_address_from_guid(guid, true);
                          if (resultsMap[i][j] === macAddress) {
                            resultsMap[i][j] = z;
                          }
                        }
                      }
                    }
                    this.restoreList = resultsMap;
                    this.showUncat = false;
                    console.log('showList', resultsMap);
                  }
                };
                updateFun();
              },
              () => {}
            );

            return;
            //get this network devices
            let targetList = cloneDeep(this.deviceList);
            //await this.updateDeviceSettings();
            return new Promise(async (resolve, reject) => {
              // command bytes: [head, tail]
              const meshCommands = [];
              targetList.forEach((e, index) => {
                if (!e.checked) {
                  return;
                }
                let head_group = 0;
                let tail_group = 1;
                if (e.deviceNetworkSize > 1) {
                  if (isset(e.network_1)) {
                    let networkMapList = JSON.parse(e.network_1);
                    let idList = networkMapList.map((kitem) => kitem.network_id);
                    let checkIndex = idList.indexOf(this.networkIndex);
                    if (checkIndex != -1) {
                      if (checkIndex == 1) {
                        head_group = 2;
                        tail_group = 3;
                      } else if (checkIndex == 2) {
                        head_group = 4;
                        tail_group = 5;
                      }
                    }
                  }
                }
                let headBytes = '8500010000000000000000000000';
                let tailBytes = '8500010000000000000100000000';
                meshCommands.push({
                  guid: e.device,
                  bytes: ['85000000', '850200', tailBytes, '850201', headBytes, '850200'],
                });
              });

              //tindy the data to the list
              meshCommands.forEach((e) => {
                e.profileDevice = targetList.find((d) => d.device === e.guid);
              });
              console.log('meshCommands', meshCommands);
              let control_index = 0;
              for (let i in meshCommands) {
                const mac = core_utils_get_mac_address_from_guid(meshCommands[i].guid);
                const toast = app.toast.create({
                  position: 'center',
                  text: `${_('Update')} ${meshCommands[i].profileDevice.device_model} <br /> ${meshCommands[i].profileDevice.roomInfo} ${mac}...`,
                });
                toast.open();
                try {
                  await this.connectRetryDefaultPaw(meshCommands[i].guid);
                  //await peripheral[meshCommands[i].guid].connect();
                  let list = meshCommands[i].bytes;
                  let postCommandList = [];
                  for (let j in list) {
                    postCommandList.push({
                      service: 'ff80',
                      characteristic: 'ff81',
                      data: list[j],
                    });
                  }
                  postCommandList.push({
                    service: 'ff80',
                    characteristic: 'ff81',
                    data: '810e',
                  });
                  await peripheral[meshCommands[i].guid].write(postCommandList);
                  control_index++;
                } catch (error) {
                  console.log(error);
                  app.toast.close();
                  setTimeout(() => {
                    app.dialog.confirm(
                      `${_('Update')} ${meshCommands[i].profileDevice.roomInfo} ${mac} ${_('failed,retry?')}`,
                      async () => {
                        for (let z = control_index; z < meshCommands.length; z++) {
                          const mac = core_utils_get_mac_address_from_guid(meshCommands[z].guid);
                          const toast = app.toast.create({
                            position: 'center',
                            text: `${_('Update')} ${meshCommands[z].profileDevice.device_model} <br /> ${meshCommands[z].profileDevice.roomInfo} ${mac}...`,
                          });
                          toast.open();
                          try {
                            await peripheral[meshCommands[z].guid].connect();
                            let list = meshCommands[z].bytes;
                            let postCommandList = [];
                            for (let j in list) {
                              postCommandList.push({
                                service: 'ff80',
                                characteristic: 'ff81',
                                data: list[j],
                              });
                            }
                            postCommandList.push({
                              service: 'ff80',
                              characteristic: 'ff81',
                              data: '810e',
                            });
                            await peripheral[meshCommands[z].guid].write(postCommandList);
                            control_index++;
                          } catch (errors) {
                            app.toast.close();
                            setTimeout(() => {
                              app.dialog.alert(_(`${_('Update')} ${meshCommands[z].profileDevice.roomInfo} ${mac} ${_('failed')}`));
                            }, 500);
                            return;
                          }
                        }
                      },
                      () => {}
                    );
                  }, 500);
                  return;
                }
              }
              if (control_index >= meshCommands.length) {
                app.toast.show({
                  position: 'center',
                  text: _('Update Successfully'),
                  closeTimeout: 2000,
                });
                // app.dialog.confirm(
                //   `${_('The configuration is complete. It will take some time for the devices to network with each other. Do you want to go back?')}`,
                //   () => {
                //     mainView.router.back();
                //   },
                //   () => {}
                // );
                emitter.emit('network/status', { code: 1 });
              }
              setTimeout(
                () => {
                  app.toast.close();
                  app.dialog.close();
                },
                1000 * 60 * 2
              );
              app.dialog.close();
            });
          },
          async editDeviceInNetwork() {
            app.dialog.preloader();
            try {
              await http2.request(encodeURI('/api/resource/Profile/' + erp.info.profile.name), {
                method: 'PUT',
                responseType: 'json',
                dataType: 'json',
                responseType: 'json',
                serializer: 'json',
                timeout: 60,
                data: {
                  profile_device: this.deviceList,
                },
              });
              app.dialog.close();
              erp.info.profile.profile_device = this.deviceList;
              //save the ble command
              await this.updateDeviceNetwork();
              //app.dialog.alert('Successfully');
            } catch (error) {
              app.dialog.close();
              app.dialog.alert(error);
            }
          },
          async saveDeviceInNetwork() {
            app.dialog.preloader();
            this.deviceList.forEach((item) => {
              if ((item.checked && item.network_id == 0) || (item.deviceNetworkSize > 1 && edit == 0 && item.checked)) {
                item.network_id = this.networkIndex;
              }
            });
            //in order to deal with the mutiway network save
            let postList = cloneDeep(this.deviceList);
            postList.forEach((item) => {
              if (item.deviceNetworkSize > 1 && item.network_id == this.networkIndex) {
                //check if have this network
                if (isset(item.network_1)) {
                  let mapList = JSON.parse(item.network_1);
                  let checkIndex = 0;
                  if (mapList.length) {
                    let idList = mapList.map((zitem) => parseInt(zitem.network_id));
                    if (idList.indexOf(parseInt(this.networkIndex)) == -1 && idList.length < 3) {
                      mapList.push({
                        network_id: this.networkIndex,
                        network_position: 0,
                      });
                    }
                  } else {
                    mapList.push({
                      network_id: this.networkIndex,
                      network_position: 0,
                    });
                  }
                  item.network_1 = JSON.stringify(mapList);
                } else {
                  item['network_1'] = JSON.stringify([
                    {
                      network_id: this.networkIndex,
                      network_position: 0,
                    },
                  ]);
                }
              }
            });
            console.log('postList', postList);
            try {
              await http2.request(encodeURI('/api/resource/Profile/' + erp.info.profile.name), {
                method: 'PUT',
                responseType: 'json',
                dataType: 'json',
                responseType: 'json',
                serializer: 'json',
                timeout: 60,
                data: {
                  profile_device: postList,
                },
              });
              app.dialog.close();
              erp.info.profile.profile_device = this.deviceList;
              emitter.emit('device_network_update');
              console.log('this.deviceList', this.deviceList);
              let targetList = this.deviceList.filter((item) => this.dealwithShow(item));
              if (targetList.length == 0) {
                app.dialog.alert(_('No devices need to be networked'));
                return;
              }
              this.index = 1;
              this.sortStatus = true;
              //app.dialog.alert('Successfully');
            } catch (error) {
              app.dialog.close();
              app.dialog.alert(error);
            }
          },
          invertBytes(str){
            const result = [];
            for(let i = 0;i<str.length;i+=2){
              result.push(str.substring(i,i+2));
            }
            return result.reverse().join('');
          },
          dealMeshHeadSet(item) {
            //console.log(item);
            let status = true;
            if (item.meshHeadSet) {
            }
          },
          async tindyNetworkSize(item, p) {
            if (!isset(p)) {
              return;
            }
            let manufactureData = isset(p.manufactureData) ? p.manufactureData : '000000000000000000';
            let connectedSize = 0x0f & parseInt(manufactureData.substring(2, 4), 16),
              meshHeadSet = (0x10 & parseInt(manufactureData.substring(2, 4), 16)) > 0 ? true : false,
              meshHeadConnect = (0x20 & parseInt(manufactureData.substring(2, 4), 16)) > 0 ? true : false,
              meshTailSet = (0x40 & parseInt(manufactureData.substring(2, 4), 16)) > 0 ? true : false,
              meshTailConnect = (0x80 & parseInt(manufactureData.substring(2, 4), 16)) > 0 ? true : false,
              meshSize = parseInt(manufactureData.substring(0, 2), 16),
              noQuota = (0x20 & parseInt(manufactureData.substring(14, 16), 16)) > 0 ? true : false,
              clockSet = (0x40 & parseInt(manufactureData.substring(14, 16), 16)) > 0 ? true : false,
              pviOn = (0x80 & parseInt(manufactureData.substring(14, 16), 16)) > 0 ? true : false;

            item.meshHeadSet = meshHeadSet;
            item.meshHeadConnect = meshHeadConnect;
            item.meshTailSet = meshTailSet;
            item.meshTailConnect = meshTailConnect;
            item.meshSize = meshSize;
          },
          async scan() {
            await bleManager.stopScan();
            await bleManager.wait(200);
            bleManager.scan(this.onDiscovery, async () => {
              await bleManager.wait(5000);
              this.scan();
            });
          },
          async onDiscovery(p) {
            if (!isset(p)) {
              return;
            }
            setTimeout(() => {
              if (!isset(peripheral[p.guid])) {
                peripheral[p.guid] = new Peripheral(p);
                this.updateDevices(p);
              } else {
                //peripheral[p.guid].update(p);
                this.updateDevices(p);
              }
            }, 10);
          },
          updateDevices(p) {
            if (!isset(p)) {
              return;
            }
            if (p.guid == '3934623535353937353330651202191d') {
              //console.log(p)
            }
            this.deviceList.forEach((item) => {
              if (item.device == p.guid) {
                if (isset(p.rssi)) {
                  if (p.rssi >= 1000) {
                    item.signal = 0;
                    item.bluetooth = 0;
                    item.mesh = 0;
                  } else {
                    if (p.rssi > -60) item.signal = 5;
                    else if (p.rssi > -70) item.signal = 3;
                    else item.signal = 1;
                  }
                }
                this.tindyNetworkSize(item, p);
              }
            });
          },
          startScan() {
            ble.stopScan(
              () => {
                ble.startScanWithOptions(
                  ['fff0', 'ff70', 'ffB0', 'ff80'],
                  {
                    reportDuplicates: true,
                    scanMode: 'lowLatency',
                  },
                  (peripheral) => {
                    //console.log("this_peripheral",peripheral);
                    erp.script.ha_discover_ble_peripheral(peripheral);
                  },
                  () => {
                    // this.startScan();
                  }
                );
              },
              () => {
                this.startScan();
              }
            );
          },
          stopScan() {
            ble.stopScan(
              function () {},
              function () {}
            );
          },
        },
        computed: {},
        beforeDestroy() {},
      });
    });

    $on('pageBeforeRemove', (e, page) => {});

    $onUnmounted(() => {
      if (vueApp) {
        vueApp.$destroy();
      }
    });

    return $render;
  };
</script>

<style>
  .checkbox i.icon-checkbox {
    opacity: 1;
  }
</style>
